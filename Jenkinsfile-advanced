pipeline {
    agent any

    triggers {
        pollSCM('H/5 * * * *')
    }

    options {
        timeout(time: 1, unit: 'HOURS')
        buildDiscarder(logRotator(numToKeepStr: '10'))
        skipStagesAfterUnstable()
        timestamps()
    }

    environment {
        DOCKER_IMAGE = 'kkaann/myapp'
        IMAGE_TAG = "${BUILD_NUMBER}"
        KIND_CLUSTER = 'kind'
        KUBECONFIG = 'C:\\ProgramData\\Jenkins\\.jenkins\\kind-kubeconfig.yaml'
        
        // Notification settings
        SLACK_CHANNEL = '#devops-alerts'
        TEAM_EMAIL = 'devops-team@example.com'
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    sendNotification('STARTED', 'Pipeline started')
                }
                echo 'ğŸ“¥ Checking out code...'
                checkout scm
            }
        }

        stage('Build Docker Image') {
            steps {
                echo 'ğŸ³ Building Docker image...'
                script {
                    bat """
                        docker build -t ${DOCKER_IMAGE}:${IMAGE_TAG} .
                        docker tag ${DOCKER_IMAGE}:${IMAGE_TAG} ${DOCKER_IMAGE}:latest
                    """
                    sendNotification('INFO', "Docker image built: ${DOCKER_IMAGE}:${IMAGE_TAG}")
                }
            }
        }

        stage('Run Unit Tests') {
            steps {
                echo 'âœ… Running unit tests...'
                bat 'npm install'
                bat 'npm test'
            }
        }

        stage('Security Scan') {
            steps {
                echo 'ğŸ”’ Running security scan...'
                script {
                    def scanResult = bat(
                        script: "docker run --rm ${DOCKER_IMAGE}:${IMAGE_TAG} npm audit --audit-level=high",
                        returnStatus: true
                    )
                    if (scanResult == 0) {
                        sendNotification('SUCCESS', 'âœ… Security scan passed - no vulnerabilities found')
                    } else {
                        sendNotification('WARNING', 'âš ï¸ Security vulnerabilities detected')
                    }
                }
            }
        }

        stage('Load Image to Kind') {
            steps {
                echo 'ğŸ“¦ Loading image to Kind cluster...'
                script {
                    bat """
                        kind load docker-image ${DOCKER_IMAGE}:${IMAGE_TAG} --name ${KIND_CLUSTER}
                        kind load docker-image ${DOCKER_IMAGE}:latest --name ${KIND_CLUSTER}
                    """
                }
            }
        }

        stage('Deploy to Dev') {
            steps {
                echo 'ğŸš€ Deploying to Dev environment...'
                script {
                    bat """
                        kubectl apply -f environments/dev/deployment.yaml
                        kubectl set image deployment/myapp myapp=${DOCKER_IMAGE}:${IMAGE_TAG} -n dev
                        kubectl rollout status deployment/myapp -n dev --timeout=2m
                    """
                    sendNotification('SUCCESS', 'âœ… Deployed to DEV environment')
                }
            }
        }

        stage('Smoke Test - Dev') {
            steps {
                echo 'ğŸ§ª Running smoke tests on Dev...'
                script {
                    bat """
                        kubectl wait --for=condition=ready pod -l app=myapp -n dev --timeout=60s
                        kubectl get pods -n dev -l app=myapp
                    """
                    
                    bat "kubectl get pods -n dev -l app=myapp -o jsonpath=\"{.items[0].metadata.name}\" > pod.txt"
                    def podName = readFile('pod.txt').trim()
                    echo "Testing pod: ${podName}"
                    
                    bat "kubectl exec ${podName} -n dev -- wget -O- -q http://localhost:3000/health"
                    sendNotification('SUCCESS', 'âœ… DEV smoke tests passed')
                }
            }
        }

        stage('Deploy to Test') {
            steps {
                echo 'ğŸ§ª Deploying to Test environment...'
                script {
                    bat """
                        kubectl apply -f environments/test/deployment.yaml
                        kubectl set image deployment/myapp myapp=${DOCKER_IMAGE}:${IMAGE_TAG} -n test
                        kubectl rollout status deployment/myapp -n test --timeout=2m
                    """
                    sendNotification('SUCCESS', 'âœ… Deployed to TEST environment')
                }
            }
        }

        stage('Smoke Test - Test') {
            steps {
                echo 'ğŸ§ª Testing Test environment...'
                script {
                    bat """
                        kubectl wait --for=condition=ready pod -l app=myapp -n test --timeout=60s
                        kubectl get pods -n test -l app=myapp
                    """
                    
                    bat "kubectl get pods -n test -l app=myapp -o jsonpath=\"{.items[0].metadata.name}\" > pod.txt"
                    def podName = readFile('pod.txt').trim()
                    echo "Testing pod: ${podName}"
                    
                    bat "kubectl exec ${podName} -n test -- wget -O- -q http://localhost:3000/health"
                    sendNotification('SUCCESS', 'âœ… TEST smoke tests passed')
                }
            }
        }

        stage('Auto-Deploy to Production') {
            steps {
                echo 'ğŸŒŸ Auto-deploying to Production (approval bypassed)...'
                script {
                    sendNotification('INFO', 'ğŸš€ Auto-deploying to PRODUCTION')
                    echo 'âš ï¸ Note: Manual approval disabled for automated testing'
                    sleep(time: 2, unit: 'SECONDS')
                }
            }
        }

        stage('Deploy to Prod') {
            steps {
                echo 'ğŸŒŸ Deploying to Production...'
                script {
                    bat """
                        kubectl apply -f environments/prod/deployment.yaml
                        kubectl set image deployment/myapp myapp=${DOCKER_IMAGE}:${IMAGE_TAG} -n prod
                        kubectl rollout status deployment/myapp -n prod --timeout=3m
                    """
                    sendNotification('SUCCESS', 'ğŸš€ Deployed to PRODUCTION')
                }
            }
        }

        stage('Smoke Test - Prod') {
            steps {
                echo 'âœ… Testing Production...'
                script {
                    bat """
                        kubectl wait --for=condition=ready pod -l app=myapp -n prod --timeout=90s
                        kubectl get pods -n prod -l app=myapp
                    """
                    
                    bat "kubectl get pods -n prod -l app=myapp -o jsonpath=\"{.items[0].metadata.name}\" > pod.txt"
                    def podName = readFile('pod.txt').trim()
                    echo "Testing pod: ${podName}"
                    
                    bat "kubectl exec ${podName} -n prod -- wget -O- -q http://localhost:3000/health"
                    sendNotification('SUCCESS', 'âœ… PROD smoke tests passed')
                }
            }
        }
    }

    post {
        success {
            script {
                def summary = """
âœ… DEPLOYMENT SUCCESSFUL!
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Image: ${DOCKER_IMAGE}:${IMAGE_TAG}
ğŸŒ Environments: DEV â†’ TEST â†’ PROD
â±ï¸ Duration: ${currentBuild.durationString.minus(' and counting')}
ğŸ”— Build: ${env.BUILD_URL}
                """
                sendNotification('SUCCESS', summary)
            }
            
            echo 'âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
            echo 'âœ… PIPELINE COMPLETED SUCCESSFULLY!'
            echo "âœ… Docker Image: ${DOCKER_IMAGE}:${IMAGE_TAG}"
            echo 'âœ… Deployed to: DEV â†’ TEST â†’ PROD'
            echo 'âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
            
            script {
                bat """
                    echo.
                    echo === ğŸ”¹ DEV Environment ===
                    kubectl get pods -n dev -l app=myapp -o wide
                    echo.
                    echo === ğŸ”¹ TEST Environment ===
                    kubectl get pods -n test -l app=myapp -o wide
                    echo.
                    echo === ğŸ”¹ PROD Environment ===
                    kubectl get pods -n prod -l app=myapp -o wide
                    echo.
                    echo âœ… All environments deployed successfully!
                """
            }
        }
        
        failure {
            script {
                def failedStage = env.STAGE_NAME ?: 'Unknown'
                def errorMsg = """
âŒ DEPLOYMENT FAILED!
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âŒ Stage: ${failedStage}
ğŸ“¦ Image: ${DOCKER_IMAGE}:${IMAGE_TAG}
â±ï¸ Duration: ${currentBuild.durationString.minus(' and counting')}
ğŸ”— Build: ${env.BUILD_URL}console
                """
                sendNotification('FAILURE', errorMsg)
            }
            
            echo 'âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
            echo 'âŒ PIPELINE FAILED!'
            echo 'âŒ Check the logs above for details'
            echo 'âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
        }
        
        unstable {
            script {
                sendNotification('WARNING', "âš ï¸ Build unstable: ${env.BUILD_URL}")
            }
        }
        
        always {
            echo 'ğŸ§¹ Cleaning up Docker images...'
            bat 'docker image prune -f || exit /b 0'
            
            // Generate deployment report
            script {
                def report = generateDeploymentReport()
                writeFile file: 'deployment-report.txt', text: report
                archiveArtifacts artifacts: 'deployment-report.txt', allowEmptyArchive: true
            }
        }
    }
}

// Helper function for notifications
def sendNotification(String status, String message) {
    def color = 'good'
    def emoji = 'âœ…'
    
    switch(status) {
        case 'SUCCESS':
            color = 'good'
            emoji = 'âœ…'
            break
        case 'FAILURE':
            color = 'danger'
            emoji = 'âŒ'
            break
        case 'WARNING':
            color = 'warning'
            emoji = 'âš ï¸'
            break
        case 'INFO':
            color = '#439FE0'
            emoji = 'â„¹ï¸'
            break
        case 'STARTED':
            color = '#439FE0'
            emoji = 'ğŸš€'
            break
    }
    
    // Console output
    echo "${emoji} ${message}"
    
    // Slack notification (if webhook configured)
    try {
        if (env.SLACK_WEBHOOK_URL) {
            def payload = """
            {
                "text": "${emoji} ${message}",
                "channel": "${env.SLACK_CHANNEL}"
            }
            """
            bat """
                powershell -Command "Invoke-RestMethod -Uri '${env.SLACK_WEBHOOK_URL}' -Method Post -Body '${payload}' -ContentType 'application/json'"
            """
        }
    } catch (Exception e) {
        echo "Slack notification failed: ${e.message}"
    }
    
    // Email notification (optional - only for important events)
    if (status in ['SUCCESS', 'FAILURE']) {
        try {
            emailext(
                subject: "${emoji} Jenkins Build ${status}: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                body: """
                    <h2>${emoji} Build ${status}</h2>
                    <p><strong>Job:</strong> ${env.JOB_NAME}</p>
                    <p><strong>Build Number:</strong> ${env.BUILD_NUMBER}</p>
                    <p><strong>Message:</strong> ${message}</p>
                    <p><strong>URL:</strong> <a href="${env.BUILD_URL}">${env.BUILD_URL}</a></p>
                """,
                to: env.TEAM_EMAIL,
                mimeType: 'text/html'
            )
        } catch (Exception e) {
            echo "Email notification failed: ${e.message}"
        }
    }
}

// Generate deployment report
def generateDeploymentReport() {
    def timestamp = new Date().format('yyyy-MM-dd HH:mm:ss')
    return """
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            DEPLOYMENT REPORT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Generated: ${timestamp}
Build Number: ${env.BUILD_NUMBER}
Image: ${env.DOCKER_IMAGE}:${env.IMAGE_TAG}
Status: ${currentBuild.currentResult}
Duration: ${currentBuild.durationString.minus(' and counting')}
Build URL: ${env.BUILD_URL}

ENVIRONMENTS DEPLOYED:
- DEV   âœ…
- TEST  âœ…
- PROD  âœ… (Auto-approved)

CHANGES IN THIS BUILD:
${getChangeLog()}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
}

// Get changelog
def getChangeLog() {
    def changeLogSets = currentBuild.changeSets
    if (changeLogSets.isEmpty()) {
        return "No changes"
    }
    
    def changes = []
    for (int i = 0; i < changeLogSets.size(); i++) {
        def entries = changeLogSets[i].items
        for (int j = 0; j < entries.length; j++) {
            def entry = entries[j]
            changes << "â€¢ ${entry.msg} (${entry.author})"
        }
    }
    return changes.join('\n')
}
